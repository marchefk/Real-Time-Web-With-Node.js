{
  "_args": [
    [
      {
        "raw": "asynquence-contrib",
        "scope": null,
        "escapedName": "asynquence-contrib",
        "name": "asynquence-contrib",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "D:\\Projekty\\Real Time Web with Node\\day2\\exercises"
    ]
  ],
  "_from": "asynquence-contrib@latest",
  "_id": "asynquence-contrib@0.28.2",
  "_inCache": true,
  "_location": "/asynquence-contrib",
  "_nodeVersion": "8.6.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/asynquence-contrib-0.28.2.tgz_1509371388729_0.9248550394549966"
  },
  "_npmUser": {
    "name": "getify",
    "email": "getify@gmail.com"
  },
  "_npmVersion": "5.5.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "asynquence-contrib",
    "scope": null,
    "escapedName": "asynquence-contrib",
    "name": "asynquence-contrib",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/asynquence-contrib/-/asynquence-contrib-0.28.2.tgz",
  "_shasum": "df45a631c9e451a48b4681cad9c2fc7e1df6b2e4",
  "_shrinkwrap": null,
  "_spec": "asynquence-contrib",
  "_where": "D:\\Projekty\\Real Time Web with Node\\day2\\exercises",
  "author": {
    "name": "Kyle Simpson",
    "email": "getify@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/getify/asynquence/issues",
    "email": "getify@gmail.com"
  },
  "dependencies": {},
  "description": "additional plugins for asynquence",
  "devDependencies": {
    "babel-core": "~5.8.12",
    "es-feature-tests": "latest",
    "freshy": "~0.0.2",
    "minimist": "~0.2.0",
    "native-promise-only": "latest",
    "uglify-js": "~2.4.24"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-HdZEw18kbiMbVyTRnLzLvwBs2arUFO05dWrEolDxEcUJu7jw8bLgiTfajTjxzQL7ldsMYIxrjtLpBEkM90DPYA==",
    "shasum": "df45a631c9e451a48b4681cad9c2fc7e1df6b2e4",
    "tarball": "https://registry.npmjs.org/asynquence-contrib/-/asynquence-contrib-0.28.2.tgz"
  },
  "homepage": "https://github.com/getify/asynquence/blob/master/contrib",
  "keywords": [
    "async",
    "flow-control",
    "sequences",
    "promise",
    "iterator",
    "generator"
  ],
  "license": "MIT",
  "main": "./contrib.src.js",
  "maintainers": [
    {
      "name": "getify",
      "email": "getify@gmail.com"
    }
  ],
  "name": "asynquence-contrib",
  "optionalDependencies": {},
  "readme": "# asynquence Contrib\n\nOptional *asynquence* plugin helpers.\n\n## Function-wrapping Adapter\n\nTo integrate *asynquence* into standard callback-oriented code bases, sometimes it's preferable to create wrappers around commonly used callback-oriented functions, to be used in place of the original functions. The wrapper automatically constructs an *asynquence* instance when called, and wires up the underlying call to the original callback-oriented function so that it maps its output behavior to the *asynquence* instance.\n\nFor example, we can call `ASQ.wrap(..)` to wrap `fs.readFile(..)` in Node.js, suppressing the callback in its signature and turning it into an *asynquence*-returning function:\n\n```js\nvar readfile = ASQ.wrap(fs.readFile);\n\nreadfile(\"something.txt\",{ encoding: \"utf8\" })\n.val(function(contents){\n    // file contents\n})\n.or(function(err){\n    // oops, `err` in reading file!\n});\n```\n\n**Note:** `ASQ.wrap(..)` creates a function which will automatically be async in nature, even if the underlying function would normally have called its callback immediately/synchronously. **DO NOT RELY** on ordered side-effects of such wrapped functions.\n\nMost of Node.js's standard functions expect an \"error-first\" style callback, and they also expect it to be at the end of the arguments list (aka \"parameters first\"). The default settings for `ASQ.wrap(..)` assume that sort of function signature.\n\nHowever, you may need to use *asynquence* with other sorts of function signatures.\n\nFor example, some functions are the opposite in parameter order (aka \"parameters last\"), where the callback must be the first argument and any other parameters are passed after it. You can pass an options-object as the second parameter to `ASQ.wrap(..)` to signal alternative function signature behavior:\n\n```js\nfunction doSomething(cb,p1,p2) {\n    // do something with `p1` and `p2`, then later\n    // call `cb` as an error-first cb\n}\n\nvar better = ASQ.wrap(doSomething,{ params_last: true });\n\nbetter(\"val 1\",\"val 2\")\n.val(function(result){\n    // result\n})\n.or(function(err){\n    // oops, `err` occurred!\n});\n```\n\nYou also may want to specify a specific `this` binding to use with the underlying function/method call. You can do such with the normal JS `.bind(..)` utility, like `ASQ.wrap( fn.bind(obj) )`, but that gives you permanent *hard-binding* that can't be overriden, which may or may not be suitable.\n\nIf you want the more flexible \"soft binding\" (an alternate default `this` binding -- instead of `window` / `global` -- that can still be overriden), you can specify a `this` in the options object, like so:\n\n```js\nfunction doSomething(cb) {\n    cb(this.id);\n}\n\nvar o1 = { id: 42 };\nvar o2 = { id: \"foobar\" };\n\nvar better = ASQ.wrap(doSomething,{ this: o1 });\n\n// use `o1` as default soft-bound `this`\nbetter()\n.val(function(id){\n    id; // 42\n});\n\n// `this` is still overridable\nbetter.call(o2)\n.val(function(id){\n    id; // \"foobar\"\n});\n```\n\nThe complete list of options you can pass:\n\n* `this`: (default: `{ }`) specifies a *soft-binding* (aka, alternate default) for `this` for the underlying function call being wrapped\n* `params_first`: (default: `true`) indicates \"parameters first\" style signature\n* `params_last`: (default: `false`) indicates \"parameters last\" style signature\n* `errfcb`: (default: `true`) indicates \"error-first\" style callback expected\n* `splitcb`: (default: `false`) indicates split success and error callbacks expected\n* `simplecb`: (default: `false`) indicates simple (success-only) callback expected, which assumes an error is either passed opaquely (inaccessible to *asynquence* handling) to the callback in some way (which you must handle), or an error is `throw`n to be `try..catch` caught (which *asynquence* will handle)\n* `gen`: (default: `false`) indicates that you've passed in a generator (ES6) to wrap (see below).\n* `spread`: (default: `true`) only in effect for `gen: true`, indicates that `token.messages` should be spread out as arguments to the generator instead of the normal `token` being passed.\n\nObviously, there's several mutually exclusive combinations of these options which would be ambiguous, and are thus not allowed (will result in an immediately-thrown error upon calling `wrap(..)`), such as `errfcb: false`, `params_first: true, params_last: true`, etc. **Just avoid these.** Also, `params_first: false` is allowed, and just means `params_last: true`, but the latter is more preferable to the former.\n\n### Wrapping A Generator\n\nIf you pass `gen:true` as an option, it overrides all other options, and instead returns back a function that creates a new *asynquence* sequence with the `runner(..)` plugin (see below) wired to run the generator you passed in. Whatever arguments you pass to the wrapper will pass into the generator (accessed via `token.messages` -- again, see `runner(..)` plugin below).\n\n```js\nvar g = ASQ.wrap(function*(token){\n    var x = 1;\n    for (var i=0; i < token.messages.length; i++) {\n        x = yield (x * token.messages[i]);\n    }\n},{ gen:true });\n\ng(2,3,4)\n.val(function(msg){\n    console.log(msg);    // 24\n});\n\ng(2,3,4,5)\n.val(function(msg){\n    console.log(msg);    // 120\n});\n```\n\nThe wrapper can be called one or many times, and each time will create and return a new sequence to run the generator.\n\n**Note:** See the `spread` wrapping option to spread out `token.messages` as arguments instead of passing in `token`.\n\n## Gate-step Variations\n\n* `any(..)` is like `gate(..)`, which waits for all segments to complete, except **just one segment has to eventually succeed** to proceed on the main sequence.\n* `first(..)` is like `any(..)`, except **as soon as any segment succeeds**, the main sequence proceeds (ignoring subsequent results from other segments).\n* `race(..)` is like `first(..)`, except the main sequence proceeds **as soon as any segment completes** (either success or failure).\n* `last(..)` is like `any(..)`, except only **the latest segment to complete successfully** sends its message(s) along to the main sequence.\n* `none(..)` is the inverse of `gate(..)`: the main sequence proceeds only **if all the segments fail** (with all segment error message(s) transposed as success message(s) and vice versa).\n* `map(arr, eachFn)` allows an asynchronous mapping of an array's values to another set of values. `map(..)` constructs a gate of segments, one for each item in `arr`. Each segment invokes `eachFn(..)` for the respective item in the array.\n\n    `eachFn(item, doneTrigger, ..)` receives the respective `item` in the array and a `doneTrigger` to invoke with the new value to map back to that array position. **Note:** If multiple values are passed, that item's value will be an array (*asynquence* message wrapper) collection of the values passed.\n\n    Just like with normal gates, `eachFn(..)` also receives any sequence messages passed forward from the previous main sequence step, such as `eachFn(item, doneTrigger, msg1, msg2, ..)`. And, if any segment causes an error, the rest of the `map(..)` fails and the main sequence is flagged as error'd.\n\n    If either `arr`, `eachFn` or both are not passed to `map(..)`, it will attempt to pull them from the value-message stream it received from the previous step. Even if it does so, any subsequent messages in the stream will still pass on to the `eachFn` callback.\n\n    The final success message from a `map(..)` sequence step is the newly constructed array of mapped values.\n\n## Sequence-step Variations\n\n* `until(..)` is like `then(..)`, except it **keeps re-trying until success** or `break()` (for loop semantics) before the main sequence proceeds.\n* `try(..)` is like `then(..)`, except it proceeds as success on the main sequence **regardless of success/failure signal**. If an error is caught, it's transposed as a special-format success message: `{ catch: ... }`.\n* `waterfall(..)` is like a sequence of `then(..)`s, except the output from each step is tracked, and the aggregate of all steps' success messages thus far is the input messages to the next step (step 3 gets passed success output from both 1 and 2, etc). Thus, the final output success message(s) of `waterfall(..)` is the collection of all success messages from the waterfall's steps.\n\n    An error anywhere along the waterfall behaves like an error in any sequence, immediately jumping to error state and aborting any further success progression.\n\n### `pThen` & `pCatch` Plugins\n\n`pThen` plugin provides a `pThen(..)` sequence method which is a cousin to the core built-in `then(..)`, but it works instead with similar semantics/behavior to native ES6 Promises. In other words, if you prefer the way `then(..)` works with Promises over *asynquence*'s `then(..)`, just use `pThen(..)` instead. **Note:** `pThen(..)` doesn't have the extra sugar capabilities like `then(..)` does, such as being able to accept sequences as direct parameters, etc -- it does just what Promise `then(..)` does.\n\nAlso provided is `pCatch(..)` which has the same semantics as Promise `catch(..)`: it's literally the same as calling `pThen(null, ..)`.\n\nExample:\n\n```js\nASQ(21)\n.pThen(function(msg){\n    return msg * 2;\n})\n.pThen(function(msg){\n    return ASQ(function(done){\n        setTimeout(function(){\n            done(msg);\n        },100);\n    });\n})\n.pThen(function(msg){\n    return new Promise(function(resolve,reject){\n        setTimeout(function(){\n            reject(\"Oops:\" + msg);\n        },100);\n    });\n})\n// sequence is now in error state!\n.pThen( // or .pCatch(...\n    null,\n    function(err) {\n        return err.toUpperCase();\n    }\n)\n// sequence no longer in error state since\n// `pThen`/`pCatch` registered an error handler\n// which handled the sequence error.\n.pThen(\n    function(msg) {\n        throw msg;\n    }\n)\n// sequence is now in error state again!\n.pCatch( // or .pThen(null, ...\n    function(err){\n        console.log(err); // \"OOPS:42\"\n        return \"Cool\";\n    }\n)\n// sequence no longer in error state\n.val(function(msg){\n    console.log(msg); // \"Cool\"\n})\n.or(function(){}); // never called\n```\n\nYou'll notice differences from the *asynquence* core `then(..)`, and how they match Promise `then(..)` behaviors instead:\n\n1. `pThen(..)` takes a `success` and/or `failure` handler (both optional), rather than multiple `then` handlers.\n2. The `success` handler is not provided the `done` trigger.\n3. Instead, you return either an immediate value (which then passes on to the next step at the next cycle), or a sequence or promise for a value, in which case the sequence/promise is \"unwrapped\", and procession occurs only after it resolves.\n4. If you register a `failure` handler via `pThen(..)` or `pCatch(..)`, then it swallows (so you can handle) any sequence errors to that point, and essentially resets the sequence back to success state after it is passes.\n5. You can also return a value from a `failure` handler, which is the success message passed onto the next step. **Note:** Just like with Promises, a sequence/promise returned from an `failure` handler **is not \"unwrapped\"** -- it's just passed along as a normal value.\n\n### `after` & `failAfter` Plugins\n\n`after` plugin provides a sequence instance method `after(..)` which inserts a delay into a sequence at that step. The first parameter is a number of milliseconds to wait. (Optional) additional parameters provide sequence messages to pass along (overriding previous sequence messages). Otherwise, previous sequence messages pass-through the delay automatically.\n\n`after` plugin also provides a static function version `ASQ.after(..)` which is the same as using the `ASQ().after(..)` method.\n\n\n```js\nASQ(42) // `42` gets discarded\n.after(500,\"Hello\",\"World!\")\n.val(function(msg1,msg2){\n    console.log(msg1,msg2); // \"Hello\"  \"World!\"\n});\n\nASQ.after(500)\n.val(function(){\n    console.log(\"Hello World!\");\n});\n```\n\n`failAfter` plugin provides both the sequence method `failAfter(..)` and the static function `ASQ.failAfter(..)`, which work exactly like the `after` plugin methods above, but result in failure rather than success.\n\nThe most common usage of the `failAfter` plugin is likely in combination with the `race(..)` plugin, to create \"timeout\" behavior:\n\n```js\n// make a 2 sec timeout for some action\nASQ()\n.race(\n    doSomethingAsync(..),\n    ASQ.failAfter(2000,\"Timeout!\")\n)\n.val(function(){\n    // success!\n})\n.or(function(err){\n    err; // \"Timeout!\"\n});\n```\n\n### `iterable-sequence` Plugin\n\n`iterable-sequence` plugin provides `ASQ.iterable()` for creating iterable sequences. See [Iterable Sequences](https://github.com/getify/asynquence/blob/master/README.md#iterable-sequences) for more information, and examples: [sync loop](https://gist.github.com/getify/8211148#file-ex1-sync-iteration-js) and [async loop](https://gist.github.com/getify/8211148#file-ex2-async-iteration-js).\n\n### `toPromise` Plugin\n\n`toPromise` plugin provides `.toPromise()` (takes zero parameters) on a *asynquence* sequence instance's API, which allows you to vend/fork a new **native `Promise`** that's chained off of your sequence. Use this plugin if you need to send an *asynquence* sequence instance into some other utility which requires a *thenable* or standard [Promises/A+ compliant](http://promisesaplus.com) promise.\n\n**Note:** The vended promise is forked off the sequence, leaving the original sequence intact, to be continuable as normal. The message(s) (both success and error) from the chain are passed along to the promise, but they are *also* retained in the sequence itself, as if the forked-off promise is ignored.\n\nExample:\n\n```js\n// make an asynquence sequence to use\nvar sq = ASQ(function(done){\n    setTimeout(function(){\n        done(42); // send 42 along as success message\n    },100);\n});\n\n// fork and deal with the native promise\nsq.toPromise()\n.then(\n    // success\n    function(msg){\n        console.log(msg); // 42\n    },\n    // error\n    function(err){\n        console.log(err);\n    }\n);\n\n// also continue with the original sequence\nsq\n.val(function(msg){\n    console.log(msg); // 42\n});\n```\n\nThe goal of *asynquence* is to provide everything you need for promises-based async flow control without you needing to expose and use native promises or other promise libraries/utilities. Theoretically, this plugin should only be used when *asynquence* is insufficient in some way. If you find yourself needing to regularly vend native promises from *asynquence*, perhaps *asynquence* needs to be extended to handle that use-case, so let us know!\n\n-----\n\nIf you're using *asynquence* in an older environment which doesn't have the native ES6 `Promise` built-in, but you still want to be able to use the `.toPromise()` utility, you need a `Promise` polyfill. There are plenty of choices out there, but a great one to consider is:\n\n[Native Promise Only](http://github.com/getify/native-promise-only)\n\nAs long as either the native `Promise` is there, or that global has been spec-compliant polyfilled, this `toPromise` plugin can create promises off your *asynquence* sequences.\n\n-----\n\n### `errfcb` Plugin\n\nThe `errfcb` plugin provides `errfcb()` on the main sequence instance API. Calling `errfcb()` creates a step in the sequence that will wait to proceed, and returns an \"error-first\" style (aka \"node-style\") callback to signal this waiting sequence step.  The \"error-first\" callback is suitable for any utility that expects such a callback.\n\nIf the \"error-first\" callback is then invoked with the first (\"error\") parameter having a truthy value, the main sequence is flagged for error as usual.  The value of the \"error\" parameter is provided to `.or()` callbacks as the failure reason.\n\nIf the \"error\" parameter has a falsy value, the main sequence proceeds as success.  Any other values provided to the callback are passed through as normal messages to the main sequence, and can be accessed by the next step in the sequence.\n\nExample:\n\n```js\n// Node.js: fs.readFile(..) wrapper\nfunction readFile(filename) {\n    // setup an empty sequence (much like an empty\n    // promise)\n    var sq = ASQ();\n\n    // call Node.js' fs.readFile(), but pass in\n    // an error-first callback that is automatically\n    // wired into the sequence.\n    fs.readFile( filename, sq.errfcb() );\n\n    // now, return our sequence/promise, which is waiting for the\n    // fs.readFile() call to complete.\n    return sq;\n}\n\nreadFile(\"meaningoflife.txt\")\n.then(..)    // will happen after fs.readFile invokes the \"error-first\" callback\n..\n```\n\nLow-level (contrived) example, to show how the pieces fit together:\n\n```js\nvar seq = ASQ();\nvar f =  seq.errfcb();    // now the sequence is waiting --- go ahead and add steps\nseq\n.val( function(message) { console.log(message); } )\n.or( function(err) { console.log('Bogus! ' + err); } );\n\nf(null, \"Hello, world!\");    // Success (since null is falsy) --- prints `Hello, world!`\n//f(\"oops\")            // Prints `Bogus! oops` if you call this instead of the preceding line\n```\n\n### `runner` Plugin\n\n`runner(..)` takes any combination of **iterable-sequence** or ES6 generator function (which will be iterated through step-by-step) or promise-producing function (like an ES7/ES2016 `async function`!). `runner(..)` can handle receiving either *asynquence* sequences, standard promises/thenables, thunks (see [\"thunks\" here](http://zef.me/6096/callback-free-harmonious-node-js)), or immediate values as the yielded/returned/resolved values.\n\nThe generator/iterable-sequence/promise-producer will receive any value-messages from the previous sequence step (via the *control token* -- see [CSP-style Concurrency](#csp-style-concurrency) below for explanation), and the final yielded/returned/resolved value will be passed along as the success message(s) to the next main sequence step. Error(s) if any will flag the main sequence as error, with error messages passed along as expected.\n\n#### Using a generator:\n\n```js\nfunction thunkDouble(x) {\n    return function thunk(cb) {\n        setTimeout(function(){\n            // cb is an error-first style callback\n            cb(null,x * 2);\n        },500);\n    };\n}\n\nfunction promiseDouble(x) {\n    // using ES6 `Promise`s\n    return new Promise(function(resolve,reject){\n        setTimeout(function(){\n            resolve(x * 2);\n        },500);\n    });\n}\n\nfunction seqDouble(x) {\n    return ASQ(function(done){\n        setTimeout(function(){\n            done(x * 2);\n        },500);\n    });\n}\n\nASQ(2)\n.runner(function *step(token){\n    // extract message from control-token so\n    // we can operate on it\n    var x = token.messages[0];                // 2\n\n    while (x < 100) {\n        if (x < 10) {\n            x = yield thunkDouble(x);        // 4 8 16\n        }\n        else if (x < 40) {\n            x = yield promiseDouble(x);        // 32\n        }\n        else {\n            x = yield seqDouble(x);            // 64 128\n        }\n    }\n})\n.val(function(num){\n    console.log(num);                        // 128\n});\n```\n\n#### Using an iterable-sequence:\n\n```js\nfunction thunkDouble(x) {\n    return function thunk(cb) {\n        setTimeout(function(){\n            // cb is an error-first style callback\n            cb(null,x * 2);\n        },500);\n    };\n}\n\nfunction promiseDouble(x) {\n    // using ES6 `Promise`s\n    return new Promise(function(resolve,reject){\n        setTimeout(function(){\n            resolve(x * 2);\n        },500);\n    });\n}\n\nfunction seqDouble(x) {\n    return ASQ(function(done){\n        setTimeout(function(){\n            done(x * 2);\n        },500);\n    });\n}\n\nASQ(2)\n.runner(\n    ASQ.iterable()\n    .then(function(token){\n        // extract message from control-token so\n        // we can operate on it\n        return token.messages[0];            // 2\n    })\n    .then(thunkDouble)                        // 4\n    .then(promiseDouble)                    // 8\n    .then(seqDouble)                        // 16\n)\n.val(function(num){\n    console.log(num);                        // 16\n});\n```\n\n#### Using a promise-producing function:\n\n```js\nfunction promiseDouble(x) {\n    // using ES6 `Promise`s\n    return new Promise(function(resolve,reject){\n        setTimeout(function(){\n            resolve(x * 2);\n        },500);\n    });\n}\n\nASQ(2)\n.runner(\n    // ES7 `async function`\n    async function step(token) {\n        var x = token.messages[0];            // 2\n        x = await promiseDouble(x);            // 4\n        x = await promiseDouble(x);            // 8\n        x = await promiseDouble(x);            // 16\n        return x;\n    }\n)\n.val(function(num){\n    console.log(num);                        // 16\n});\n```\n\n**Note:** Any promise-returning function will work the same way here, but the ES7 `async function` syntax is illustrated above.\n\n#### CSP-style Concurrency\n\n`runner(..)` can accept 2 or more generators (or iterable-sequences) that you can cooperatively interleave execution of, which lets you leverage a simple form of CSP-style coroutine concurrency (aka **\"cooperative multitasking\"**).\n\nGenerators/iterable-sequences will receive a *control token* with a messages channel (`.messages` property is a simple array) to use for passing messages back and forth as the coroutines interleave.\n\nIf you `yield` (or `return` in the case of iterable-sequences) that *control token* back (or a sequence/promise that eventually produces it), then you will signal to transfer control to the next (round-robbin ordering style) generator/sequence in the concurrency-grouping.\n\nOtherwise, yielding/returning of any other type of value, **including a sequence/promise**, will retain control with the current generator/iterator-step.\n\nYou can also call `.add(..)` on the *control token* to add one or more generators/iterable-sequences to the concurrency-grouping:\n\n```js\n// promise to double `v` in 1000 ms\nfunction double(v) {\n    return new Promise(function(resolve,reject){\n        setTimeout(function(){\n            resolve(v * 2);\n        },1000);\n    });\n}\n\nfunction makeGen(x,y) {\n    return function*(token){\n        token.messages.push( yield double(x) );\n        yield token;\n        token.messages.push( yield double(y) );\n    };\n}\n\nASQ()\n.runner(\n    function*(token) {\n        token.add(\n            makeGen(10,20),\n            makeGen(100,200)\n        );\n        while (token.messages.length < 4) {\n            yield token;\n        }\n        yield token.messages;\n    }\n)\n.val(function(msg){\n    console.log(msg); // [ 20, 200, 40, 400 ]\n});\n```\n\nWith both generators and iterable-sequences, the last *final* non-`undefined` value that is yielded/returned from the concurrency-grouping run will be the forward-passed message(s) to the next step in your main *asynquence* chain.\n\nIf you want to pass on the channel messages from your generator run, end your last generator by `yield`ing out the `.messages` property of the *control token* (see above snippet). Likewise with iterable-sequences, `return` the channel messages from the last iterable-sequence step.\n\nTo get a better sense of how this advanced functionality works, check out these examples:\n\n* [State Machine](http://jsbin.com/luron/1/edit?js,console) with simple generator co-routines (hidden CSP)\n* [Ping Pong](http://jsbin.com/qutabu/1/edit?js,output) (from [js-csp](https://github.com/ubolonton/js-csp/blob/master/README.md#examples) and the [go ping-pong](http://talks.golang.org/2013/advconc.slide#6) example)\n* [Two generators paired as CSP-style co-routines](https://gist.github.com/getify/10172207)\n\n#### go-Style CSP API Emulation\n\nIf you've heard of go-style CSP concurrency, such as in [Clojure's core.async](https://clojure.github.io/core.async/), or in various JS ports such as [@jlongster](http://github.com/jlongster)'s [js-csp fork](https://github.com/jlongster/js-csp) (also, [read his blog post](http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript)) of [ubolonton's js-csp](https://github.com/ubolonton/js-csp), *asynquence* has a (nearly-identical) API emulation layer that you can drop on top of *asynquence*'s CSP-flavored `runner(..)` mechanism described above to express channel-based concurrency.\n\nFor example:\n\n```js\nASQ()\n.runner(\n    ASQ.csp.go(function*(ch){\n        console.log(\"sending value\");\n        yield ASQ.csp.put(ch,42);\n        console.log(\"send complete\");\n    }),\n    ASQ.csp.go(function*(ch){\n        console.log(\"waiting...\");\n        yield ASQ.csp.take( ASQ.csp.timeout(1000) );\n        console.log(\n            \"received value:\",\n            yield ASQ.csp.take(ch)\n        );\n    })\n)\n.val(function(){\n    console.log(\"all done\");\n});\n\n// sending value\n// waiting...\n// received value: 42\n// send complete\n// all done\n```\n\nAs you can see, by calling `yield ASQ.csp.put(..)`, you're blocking that coroutine (aka \"goroutine\") while it attempts to send the value on the channel. The other coroutine doesn't take the value right away (it waits 1000ms). Then `yield ASQ.csp.take(..)` blocks until a value can be taken from the channel.\n\nIn this case, `42` is already waiting to be sent, but if there were no value yet, that coroutine would block and wait. Once the value is taken and the second coroutine finishes, the first coroutine is unblocked and it finishes as well.\n\nThe main concept with go-style CSP -- channel-based concurrency -- is that you use `put(..)`s and `take(..)`s on a shared channel (like a message stream) to coordinate interactions across multiple coroutines -- implicit transfers of control. Both `put(..)` and `take(..)` block, so that regardless of which action is taken \"first\", both must pair before the message can be sent across the channel.\n\nTo use the go-style API emulation layer, you'll need (at least) the `iterable()` and `pThen()`/`pCatch()` contrib plugins.\n\nIn the browser:\n```html\n<script src=\"asq.js\"></script>\n<script src=\"contrib.js\"></script>\n<script src=\"asq-go-csp.js\"></script>\n```\n\nIn node:\n```js\nvar ASQ = require(\"asynquence\");\n\nrequire(\"asynquence-contrib\");\nrequire(\"asynquence-contrib/asq-go-csp.js\");\n```\n\ngo-style CSP can be a very powerful abstraction for certain concurrency tasks, so using this API emulation layer gives you even more choices for expressing and managing async flow control in your JS programs.\n\nCheck out [several more examples of go-style CSP](https://gist.github.com/getify/e0d04f1f5aa24b1947ae).\n\n### `react` Plugin\n\nConsider this kind of ugly code:\n\n```js\n$(\"#button\").click(function(evt){\n   ASQ(this.id)\n   .then(..)\n   .seq(..)\n   .then(..)\n   .val(..)\n});\n```\n\nEach time the button is clicked, a new sequence is defined and executed to \"react\" to the event. But it's a little awkward and ugly that the sequence must be (re)defined each time, *inside* the event listener.\n\nThe `react` plugin separates the capabilities of listening for events and of responding to them, providing first-class syntactic support for the *asynquence* \"reactive sequence\" pattern, inspired by [RxJS Reactive Observables](http://rxjs.codeplex.com/). It essentially combines *asynquence*'s flow-control with repeatable event handling.\n\n1. `react(..)` accepts a listener setup handler, which will receive a reactive trigger (called `proceed` in the snippet below) that event listener(s) \"react\" with by invoking. It will also receive a function you can call one or more times to register a *teardown* handler (to unbind event handlers, etc).\n2. The rest of the chain appears as a (mostly) normal *asynquence* sequence, which will then be repeat-executed each time a new sequence message is pumped.\n    - **Note:** The following sequence methods and plugins are not present on a reactive sequence, as their usage would be invalid: `pipe(..)`, `fork(..)`, `errfcb(..)`, `pThen(..)`/`pCatch(..)`, and `toPromise(..)`.\n\nThe `react` plugin reverses the paradigm of the first snippet, providing a way to specify the sequence externally and once, and have it be re-triggered each time an event fires.\n\n```js\nvar rsq = ASQ.react(\n   // this listener setup handler will be called only once\n   function setup(proceed,registerTeardownHandler){\n      // fire off a new sequence for each click\n      function handler(evt) {\n         // we can call `proceed(..)` (or whatever you want\n         // to call the param!) every time our stream/event\n         // fires, instead of just once like normal promise\n         // resolution\n         proceed(this.id);\n      }\n\n      $(\"#button\").click(handler);\n\n      // register a handler to be called when tearing down\n      // the reactive sequence handling\n      registerTeardownHandler(function(){\n         $(\"#button\").unbind(\"click\",handler);\n      });\n\n      // inside our `setup` handler, `this` will point to\n      // the reactive sequence, which has a `stop()` method\n      // that tears down the reactive sequence handling\n      EVTHUB.on(\"finish\",this.stop);\n   }\n)\n// each time our reactive event fires,\n// process the rest of this sequence\n.then(..)\n.seq(..)\n.then(..)\n.val(..);\n\n// later, to stop the reactive sequence handling:\nEVTHUB.on(\"totally-done\",rsq.stop);\n```\n\nInside the `react(..)` listener setup function, you can set up as many listeners for any kind of events (ajax, timers, click handlers, etc) as you want, and for each, all you need to do to fire off the sequence is call the `proceed(..)` (or whatever you want to name it!) callback. Whatever messages you pass to `proceed(..)` will pass along to the first step of the sequence instance.\n\nCalling `stop()` on a reactive sequence triggers any registered teardown handlers and permanently stops all activity for that sequence. The reactive sequence also has `pause()` and `resume()` methods to temporarily teardown and then restart a sequence's activity. **Note:** A paused sequence emulates a similar notion to a \"cold observable\", where as a running sequence is like a \"hot observable\".\n\nThe reactive sequence API can be extended with a new instance method by calling `ASQ.react.extend(..)`. The first argument is the API method name and the second argument is a build function that defines the extension. This build function receives the current API as its only argument and must return the newly defined API method. This extensibility works almost identically to extending the main *asynquence* instances, but only affects reactive sequences.\n\nThe `proceed` function has two helpers on it for dealing with streams (particularly node streams): `proceed.onStream(..)` and `proceed.unStream(..)`. `onStream(..)` takes one or more streams and subscribes the `data` and `error` events to call the `proceed` function. `unStream(..)` takes one or more streams to unsubscribe, so you would likely use it in a registered teardown handler. For example:\n\n```js\nvar rsq = ASQ.react(function(proceed,registerTeardownHandler){\n    proceed.onStream( mydatastream );\n\n    registerTeardownHandler(function(){\n        proceed.unStream( mydatastream );\n    });\n})\n.val(function(v){\n    if (v instanceof Error) throw v;\n    // ..\n})\n// ..\n.or(function(err){\n    console.log(err);\n});\n```\n\nFor a more real-world type of example, see [reactive sequences + `gate()`](http://jsbin.com/rozipaki/6/edit?js,output). Here's [another example](https://gist.github.com/getify/bba5ec0de9d6047b720e), which handles http request/response streams with reactive sequences.\n\n#### `react` Helpers\n\nThe `reactHelpers` plugin includes several very useful helpers for the reactive sequences.\n\n##### Reactive Sequence/RxJS Conversion\n\nSome utilities for interoperating between asynquence reactive sequences and RxJS Observables:\n\n* `toObservable()` is a sequence method on a normal asynquence sequence or a reactive sequence that produces an RxJS Observable (requires RxJS to be present)\n* `ASQ.react.fromObservable(..)` static utility that receives an RxJS-compatible Observable and turns it into a reactive sequence.\n\n##### Directly Pumping Sequence Messages\n\nSimilar to RxJS Subjects, reactive sequences can be directly pumped with sequence messages.\n\n* `ASQ.react.of(..)` creates a new reactive sequence as if produced by `ASQ.react(..)`, but if you provide one or more values as arguments, they are pumped as initial messages in the sequence.\n* `push(..)` on a reactive sequence instance will pump new messages into the sequence at any time.\n\n##### Composition\n\nSome utilities for combining (aka composing) multiple reactive sequences:\n\n* `ASQ.react.all(..)` (alias `zip(..)` as with RxJS) creates a new reactive sequence that listens to one or more reactive sequences, and fires an event (with all messages included) whenever *all* observed sequences have fired an event. Each sequence's event messages are buffered in case the sequences are producing at different rates.\n* `ASQ.react.allLatest(..)`: same as `all(..)` except buffer size of 1, so it only keeps the latest message from each sequence.\n* `ASQ.react.latest(..)` (alias `combineLatest(..)` as with RxJS) is the same as `all(..)` except no buffering is done -- only the *latest* message from each sequence is kept.\n* `ASQ.react.any(..)` (alias `merge(..)` as with RxJS) creates a new reactive sequence that listens to one or more reactive sequences, and fires as soon as *any* observed sequence fires an event.\n\nBecause of how `ASQ.react.all(..)` and `ASQ.react.any(..)` operate, you can effectively *duplicate* a reactive sequence simply by passing only it to either of the utilities.\n\n###### Transformation\n\nSome utilities for transforming/mapping/projecting individual reactive sequences to new sequences:\n\n* `ASQ.react.distinct(rsq)`: creates a new reactive sequence that listens to a reactive sequence, and only fires whenever a *distinct* (ignoring duplicates with simple, shallow comparison) event message comes through from the observed sequence events.\n* `ASQ.react.distinctConsecutive(..)` (alias `distinctUntilChanged(..)` as with RxJS): same as `distinct(..)`, but ignores only consecutive duplicate (simple, shallow comparison) event messages from a single sequence.\n* `ASQ.react.filter(..)`: creates a new reactive sequence that listens to a reactive sequence, and only fires whenever an event message is not filtered out.\n\nA great way to visualize how these different reactive sequence compositions/transformations work is [RxMarbles](http://rxmarbles.com/).\n\n## Using Contrib Plugins\n\nIn the browser, include the `contrib.js` file along with the *asynquence* library file (`asq.js`). Doing so automatically extends the API with the plugins.\n\nIn Node.js, you install the `asynquence-contrib` package alongside the `asynquence` package. **Note:** The *asynquence-contrib* package will return the *asynquence* instance for you, so you technically only need this if using both:\n\n```js\n// Note: requiring \"asynquence\" not strictly needed here,\n// since contrib will retrieve and return it automatically\n\nvar ASQ = require(\"asynquence-contrib\");\n```\n\nThey can then be used together directly, like this:\n\n```js\nASQ()\n.try(foo)\n.until(bar)\n.then(baz);\n```\n\n**Note:** If you load contrib bundle(s) that cannot find a peer *asynquence* top-level package to load and use, a dependency-injection function is instead returned, which expects to be called with either an *asynquence* instance, or a relative path specifying where to load it.\n\n## Building Contrib Bundle\n\nThere is a utility provided to bundle the contrib plugins.\n\n```\nbundle.js usage:\n  bundle.js [ {OPTION} .. ] [ {PLUGIN-NAME} .. ]\n\n--help                    prints this help\n--wrapper=filename        wrapper filename (\"contrib-wrapper.js\")\n--bundle=filename         bundle filename (\"contrib.src.js\")\n--min-bundle=filename     minified-bundle filename (\"contrib.js\")\n--exclude={PLUGIN-NAME}   exclude a plugin from bundling\n\nIf you don't pass any {PLUGIN-NAME} parameters, all available plugins\n(except any that are --exclude omitted) will be bundled.\n\nIf you pass one or more {PLUGIN-NAME} parameters, only the ones\nspecified (except any that are --exclude omitted) will be bundled.\n```\n\n`bundle.js` by default builds the unminified bundle `contrib.src.js`, and then builds (minifies) `contrib.js`. By default, this build includes all the `contrib/plugin.*.js` plugins.\n\nThe recommended way to invoke this utility is via npm:\n\n```\nnpm run build\n```\n\nSome plugins, like `goCSP`, use ES6 features that are transpiled to ES5 using [Babel](http://babeljs.io) for the `contrib.src.js` and `contrib.js` bundles. So, to use `goCSP` in a browser for example, you'll need to also load the Babel browser polyfill, which is available at `./node_modules/babel-core/browser-polyfill.min.js` (and use `polyfill.js` in Node).\n\nThe npm package distribution also includes `contrib-es6.src.js`, which is the unminified and non-transpiled (original native ES6 code) bundle. Also included in the package is `contrib-common.js` (and `contrib-common.src.js`), which includes only these commonly used plugins: `after`, `iterable`, `race`, `runner`, `toPromise`, and `wrap`.\n\nYou can build your own bundle and manually specify which plugins you want, by name. For example, to bundle only the `any`, `none`, and `try` plugins:\n\n```\n./bundle.js any none try\n```\n\nBy passing *option* parameters to the bundle script, you can override the default filenames used for the contrib plugin wrapper (`--wrapper=..`), bundle (`--bundle=..`), and minified-bundle (`--min-bundle=..`). These options are useful for creating multiple variations of the plugin bundle.\n\n## License\n\nThe code and all the documentation, unless otherwise noted, are released under the MIT license.\n\nhttp://getify.mit-license.org/\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/getify/asynquence.git"
  },
  "scripts": {
    "build": "npm run bundle && npm run bundle-es6 && npm run bundle-common",
    "bundle": "./bundle.js",
    "bundle-common": "npm run bundle -- --bundle=contrib-common.src.js --min-bundle=contrib-common.js after iterable race runner toPromise wrap",
    "bundle-es6": "npm run bundle -- --keep-es6 --bundle=contrib-es6.src.js",
    "prepublish": "npm run build",
    "test": "./node-tests.js"
  },
  "version": "0.28.2"
}
